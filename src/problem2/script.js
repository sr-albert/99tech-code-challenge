// Price data configuration (mock-only; no external API)
const USE_MOCK_DATA = true; // Always true; external APIs removed
const TOKEN_ICON_BASE =
  "https://raw.githubusercontent.com/Switcheo/token-icons/main/tokens";

// Generated by AI
const TOKENS_TO_FETCH = [
  "BTC",
  "ETH",
  "USDC",
  "USDT",
  "BNB",
  "SOL",
  "XRP",
  "ADA",
  "DOGE",
  "DOT",
  "MATIC",
  "AVAX",
  "LINK",
  "UNI",
  "ATOM",
  "ETC",
  "XLM",
  "ALGO",
  "VET",
  "FIL",
  "TRX",
  "EOS",
  "AAVE",
  "MKR",
  "COMP",
  "YFI",
  "SNX",
  "SUSHI",
  "CRV",
  "1INCH",
  "SWTH",
  "WBTC",
  "DAI",
  "BUSD",
  "TUSD",
  "PAXG",
  "LTC",
  "BCH",
  "XMR",
  "ZEC",
];

// Generated by AI
const MOCK_TOKEN_PRICES = {
  BTC: 106120.0,
  ETH: 3604.0,
  USDC: 1.0,
  USDT: 1.0,
  BNB: 615.5,
  SOL: 198.75,
  XRP: 0.62,
  ADA: 0.48,
  DOGE: 0.15,
  DOT: 7.25,
  MATIC: 0.85,
  AVAX: 36.8,
  LINK: 14.5,
  UNI: 6.2,
  ATOM: 8.9,
  ETC: 25.3,
  XLM: 0.12,
  ALGO: 0.18,
  VET: 0.04,
  FIL: 5.8,
  TRX: 0.11,
  EOS: 0.75,
  AAVE: 95.2,
  MKR: 2450.0,
  COMP: 55.8,
  YFI: 8500.0,
  SNX: 3.2,
  SUSHI: 1.15,
  CRV: 0.55,
  "1INCH": 0.42,
  SWTH: 0.0085,
  WBTC: 106120.0,
  DAI: 1.0,
  BUSD: 1.0,
  TUSD: 1.0,
  PAXG: 2650.0,
  LTC: 72.5,
  BCH: 245.0,
  XMR: 165.0,
  ZEC: 28.5,
};

// State management
let tokenPrices = {};
let availableTokens = [];
let fromToken = "SWTH";
let toToken = "USDC";
let fromAmount = "";
let toAmount = "";
let isCalculating = false;
let currentModal = null; // 'from' or 'to'

// DOM elements
const elements = {
  fromCurrencySelector: document.getElementById("from-currency-selector"),
  toCurrencySelector: document.getElementById("to-currency-selector"),
  fromIcon: document.getElementById("from-icon"),
  toIcon: document.getElementById("to-icon"),
  fromSymbol: document.getElementById("from-symbol"),
  toSymbol: document.getElementById("to-symbol"),
  fromAmount: document.getElementById("from-amount"),
  toAmount: document.getElementById("to-amount"),
  fromBalance: document.getElementById("from-balance"),
  toBalance: document.getElementById("to-balance"),
  fromError: document.getElementById("from-error"),
  toError: document.getElementById("to-error"),
  fromMaxBtn: document.getElementById("from-max-btn"),
  swapDirectionBtn: document.getElementById("swap-direction-btn"),
  confirmBtn: document.getElementById("confirm-btn"),
  swapForm: document.getElementById("swap-form"),
  loadingOverlay: document.getElementById("loading-overlay"),
  modalOverlay: document.getElementById("modal-overlay"),
  modalClose: document.getElementById("modal-close"),
  tokenSearch: document.getElementById("token-search"),
  tokenList: document.getElementById("token-list"),
  exchangeRate: document.getElementById("exchange-rate"),
};

async function init() {
  try {
    showLoading(true);
    await fetchTokenPrices();
    setupEventListeners();
    updateUI();
    showLoading(false);
  } catch (error) {
    console.error("Failed to initialize:", error);
    showError("Failed to load token prices. Please refresh the page.");
    showLoading(false);
  }
}

// Mock function that simulates an exchange-rate API response
function getMockTokenPrices() {
  const timestamp = Date.now();
  return TOKENS_TO_FETCH.map((symbol) => {
    const price = MOCK_TOKEN_PRICES[symbol] || 0;
    return {
      symbol: symbol,
      value: price.toString(),
      basePair: "USD",
      timestamp: timestamp,
      source: "mock",
    };
  }).filter((item) => item.value !== "0"); // Filter out tokens without prices
}

async function fetchTokenPrices() {
  try {
    let data;

    // Use mock data for development/testing (external API removed)
    console.log("Using mock token price data");
    // Simulate network delay
    await new Promise((resolve) => setTimeout(resolve, 300));
    data = getMockTokenPrices();

    // Filter tokens that have prices
    tokenPrices = {};
    availableTokens = [];

    // Tatum API returns an array of rate objects
    // Note: value is returned as a string from the API
    if (Array.isArray(data)) {
      for (const rateObj of data) {
        if (rateObj && rateObj.symbol && rateObj.value) {
          const token = rateObj.symbol.toUpperCase();
          // Parse value (can be string or number)
          const price =
            typeof rateObj.value === "string"
              ? parseFloat(rateObj.value)
              : rateObj.value;

          if (!isNaN(price) && price > 0) {
            tokenPrices[token] = price;
            availableTokens.push({
              symbol: token,
              price: price,
            });
          }
        }
      }
    } else if (typeof data === "object") {
      // Handle alternative response format if needed
      for (const [token, rateObj] of Object.entries(data)) {
        let price;
        if (typeof rateObj === "number") {
          price = rateObj;
        } else if (typeof rateObj === "string") {
          price = parseFloat(rateObj);
        } else {
          price = parseFloat(rateObj?.value || rateObj?.price || 0);
        }

        if (!isNaN(price) && price > 0) {
          tokenPrices[token.toUpperCase()] = price;
          availableTokens.push({
            symbol: token.toUpperCase(),
            price: price,
          });
        }
      }
    }

    // Sort tokens alphabetically
    availableTokens.sort((a, b) => a.symbol.localeCompare(b.symbol));

    // Ensure default tokens are available, if not, use first available tokens
    if (!tokenPrices[fromToken] && availableTokens.length > 0) {
      fromToken = availableTokens[0].symbol;
    }
    if (!tokenPrices[toToken] && availableTokens.length > 1) {
      toToken =
        availableTokens.find((t) => t.symbol !== fromToken)?.symbol ||
        availableTokens[0].symbol;
    }

    if (fromToken === toToken && availableTokens.length > 1) {
      toToken =
        availableTokens.find((t) => t.symbol !== fromToken)?.symbol ||
        availableTokens[0].symbol;
    }
  } catch (error) {
    console.error("Error fetching token prices:", error);
    throw error;
  }
}

function setupEventListeners() {
  elements.fromCurrencySelector.addEventListener("click", () =>
    openTokenModal("from")
  );
  elements.toCurrencySelector.addEventListener("click", () =>
    openTokenModal("to")
  );

  elements.fromAmount.addEventListener("input", handleFromAmountChange);
  elements.fromAmount.addEventListener("blur", validateFromAmount);
  elements.toAmount.addEventListener("input", handleToAmountChange);

  elements.fromMaxBtn.addEventListener("click", setMaxAmount);

  elements.swapDirectionBtn.addEventListener("click", swapCurrencies);

  elements.swapForm.addEventListener("submit", handleFormSubmit);

  elements.modalClose.addEventListener("click", closeTokenModal);
  elements.modalOverlay.addEventListener("click", (e) => {
    if (e.target === elements.modalOverlay) {
      closeTokenModal();
    }
  });

  elements.tokenSearch.addEventListener("input", filterTokenList);

  document.addEventListener("keydown", (e) => {
    if (e.key === "Escape" && currentModal) {
      closeTokenModal();
    }
  });
}

function handleFromAmountChange(e) {
  fromAmount = e.target.value;
  clearError("from");

  if (!fromAmount || fromAmount === "0" || fromAmount === "") {
    toAmount = "";
    elements.toAmount.value = "";
    updateExchangeRate();
    updateConfirmButton();
    return;
  }

  const amount = parseFloat(fromAmount);
  if (isNaN(amount) || amount <= 0) {
    return;
  }

  calculateToAmount();
}

function handleToAmountChange(e) {
  toAmount = e.target.value;
  clearError("to");

  if (!toAmount || toAmount === "0" || toAmount === "") {
    fromAmount = "";
    elements.fromAmount.value = "";
    updateExchangeRate();
    updateConfirmButton();
    return;
  }

  const amount = parseFloat(toAmount);
  if (isNaN(amount) || amount <= 0) {
    return;
  }

  calculateFromAmount();
}

function calculateToAmount() {
  if (isCalculating) return;

  const fromPrice = tokenPrices[fromToken];
  const toPrice = tokenPrices[toToken];

  if (!fromPrice || !toPrice) {
    showError("to", "Price data unavailable for this token pair");
    return;
  }

  if (!fromAmount || fromAmount === "") {
    toAmount = "";
    elements.toAmount.value = "";
    updateExchangeRate();
    updateConfirmButton();
    return;
  }

  const amount = parseFloat(fromAmount);
  if (isNaN(amount) || amount <= 0) {
    return;
  }

  isCalculating = true;

  const calculatedAmount = (amount * fromPrice) / toPrice;
  toAmount = calculatedAmount.toFixed(8).replace(/\.?0+$/, "");
  elements.toAmount.value = toAmount;

  updateExchangeRate();
  updateConfirmButton();
  validateFromAmount();

  isCalculating = false;
}

function calculateFromAmount() {
  if (isCalculating) return;

  const fromPrice = tokenPrices[fromToken];
  const toPrice = tokenPrices[toToken];

  if (!fromPrice || !toPrice) {
    showError("from", "Price data unavailable for this token pair");
    return;
  }

  if (!toAmount || toAmount === "") {
    fromAmount = "";
    elements.fromAmount.value = "";
    updateExchangeRate();
    updateConfirmButton();
    return;
  }

  const amount = parseFloat(toAmount);
  if (isNaN(amount) || amount <= 0) {
    return;
  }

  isCalculating = true;

  const calculatedAmount = (amount * toPrice) / fromPrice;
  fromAmount = calculatedAmount.toFixed(8).replace(/\.?0+$/, "");
  elements.fromAmount.value = fromAmount;

  updateExchangeRate();
  updateConfirmButton();
  validateFromAmount();

  isCalculating = false;
}

function setMaxAmount() {
  const balance = parseFloat(elements.fromBalance.textContent) || 0;
  if (balance > 0) {
    fromAmount = balance.toString();
    elements.fromAmount.value = fromAmount;
    handleFromAmountChange({ target: { value: fromAmount } });
  }
}

function swapCurrencies() {
  const tempToken = fromToken;
  const tempAmount = fromAmount;

  fromToken = toToken;
  toToken = tempToken;
  fromAmount = toAmount;
  toAmount = tempAmount;

  updateUI();
  calculateToAmount();
}

function validateFromAmount() {
  clearError("from");

  if (!fromAmount || fromAmount === "") {
    updateConfirmButton();
    return;
  }

  const amount = parseFloat(fromAmount);
  const balance = parseFloat(elements.fromBalance.textContent) || 0;

  if (isNaN(amount) || amount <= 0) {
    showError("from", "Please enter a valid amount");
    updateConfirmButton();
    return;
  }

  if (amount > balance) {
    showError("from", "Insufficient balance");
    updateConfirmButton();
    return;
  }

  if (!tokenPrices[fromToken] || !tokenPrices[toToken]) {
    showError("from", "Price data unavailable");
    updateConfirmButton();
    return;
  }

  updateConfirmButton();
}

function updateExchangeRate() {
  const fromPrice = tokenPrices[fromToken];
  const toPrice = tokenPrices[toToken];

  if (!fromPrice || !toPrice) {
    elements.exchangeRate.textContent = "";
    return;
  }

  const rate = fromPrice / toPrice;
  elements.exchangeRate.textContent = `1 ${fromToken} = ${rate.toFixed(
    6
  )} ${toToken}`;
}

function updateConfirmButton() {
  const hasValidAmount = fromAmount && parseFloat(fromAmount) > 0;
  const hasNoErrors =
    !elements.fromError.classList.contains("show") &&
    !elements.toError.classList.contains("show");
  const hasValidBalance =
    parseFloat(elements.fromBalance.textContent) >= parseFloat(fromAmount || 0);

  elements.confirmBtn.disabled = !(
    hasValidAmount &&
    hasNoErrors &&
    hasValidBalance
  );
}

function handleFormSubmit(e) {
  e.preventDefault();

  if (elements.confirmBtn.disabled) {
    return;
  }

  // Simulate notification
  alert(
    `Swap confirmed!\n\nYou will send ${fromAmount} ${fromToken}\nYou will receive ${toAmount} ${toToken}`
  );

  // Reset
  fromAmount = "";
  toAmount = "";
  elements.fromAmount.value = "";
  elements.toAmount.value = "";
  updateExchangeRate();
  updateConfirmButton();
}

function openTokenModal(type) {
  currentModal = type;
  elements.modalOverlay.classList.add("show");
  elements.tokenSearch.value = "";
  renderTokenList();
  setTimeout(() => elements.tokenSearch.focus(), 100);
}

function closeTokenModal() {
  currentModal = null;
  elements.modalOverlay.classList.remove("show");
  elements.tokenSearch.value = "";
}

function renderTokenList(filter = "") {
  const searchTerm = filter.toLowerCase().trim();
  const filteredTokens = availableTokens.filter((token) => {
    return token.symbol.toLowerCase().includes(searchTerm);
  });

  if (filteredTokens.length === 0) {
    elements.tokenList.innerHTML =
      '<div class="empty-state">No tokens found</div>';
    return;
  }

  const selectedToken = currentModal === "from" ? fromToken : toToken;

  elements.tokenList.innerHTML = filteredTokens
    .map((token) => {
      const isSelected = token.symbol === selectedToken;
      const iconUrl = `${TOKEN_ICON_BASE}/${token.symbol}.svg`;
      const price = tokenPrices[token.symbol];

      return `
      <div class="token-item ${isSelected ? "selected" : ""} ${
        !price ? "no-price" : ""
      }" 
           data-symbol="${token.symbol}">
        <img src="${iconUrl}" alt="${token.symbol}" class="token-item-icon" 
             onerror="this.src='data:image/svg+xml,%3Csvg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22%3E%3Ccircle cx=%2250%22 cy=%2250%22 r=%2240%22 fill=%22%236366f1%22/%3E%3Ctext x=%2250%22 y=%2255%22 font-size=%2230%22 text-anchor=%22middle%22 fill=%22white%22%3E${
               token.symbol[0]
             }%3C/text%3E%3C/svg%3E'">
        <div class="token-item-info">
          <span class="token-item-symbol">${token.symbol}</span>
          <span class="token-item-name">${token.symbol} Token</span>
        </div>
        ${
          price
            ? `<span class="token-item-price">$${price.toFixed(4)}</span>`
            : '<span class="token-item-price">No price</span>'
        }
      </div>
    `;
    })
    .join("");

  elements.tokenList.querySelectorAll(".token-item").forEach((item) => {
    item.addEventListener("click", () => {
      const symbol = item.dataset.symbol;
      if (currentModal === "from") {
        if (symbol === toToken) {
          toToken = fromToken;
        }
        fromToken = symbol;
      } else {
        if (symbol === fromToken) {
          fromToken = toToken;
        }
        toToken = symbol;
      }
      updateUI();
      closeTokenModal();

      if (fromAmount) {
        calculateToAmount();
      }
    });
  });
}

// Filter token list
function filterTokenList(e) {
  renderTokenList(e.target.value);
}

function updateUI() {
  elements.fromIcon.src = `${TOKEN_ICON_BASE}/${fromToken}.svg`;
  elements.fromIcon.onerror = function () {
    this.src = `data:image/svg+xml,%3Csvg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22%3E%3Ccircle cx=%2250%22 cy=%2250%22 r=%2240%22 fill=%22%236366f1%22/%3E%3Ctext x=%2250%22 y=%2255%22 font-size=%2230%22 text-anchor=%22middle%22 fill=%22white%22%3E${fromToken[0]}%3C/text%3E%3C/svg%3E`;
  };
  elements.fromSymbol.textContent = fromToken;

  elements.toIcon.src = `${TOKEN_ICON_BASE}/${toToken}.svg`;
  elements.toIcon.onerror = function () {
    this.src = `data:image/svg+xml,%3Csvg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22%3E%3Ccircle cx=%2250%22 cy=%2250%22 r=%2240%22 fill=%22%238b5cf6%22/%3E%3Ctext x=%2250%22 y=%2255%22 font-size=%2230%22 text-anchor=%22middle%22 fill=%22white%22%3E${toToken[0]}%3C/text%3E%3C/svg%3E`;
  };
  elements.toSymbol.textContent = toToken;

  // Update balance
  const fromPrice = tokenPrices[fromToken] || 0;
  const toPrice = tokenPrices[toToken] || 0;
  elements.fromBalance.textContent = (Math.random() * 1000).toFixed(4);
  elements.toBalance.textContent = (Math.random() * 1000).toFixed(4);

  updateExchangeRate();
  updateConfirmButton();
}

function showLoading(show) {
  if (show) {
    elements.loadingOverlay.classList.remove("hidden");
  } else {
    elements.loadingOverlay.classList.add("hidden");
  }
}

function showError(field, message) {
  const errorElement = field === "from" ? elements.fromError : elements.toError;
  errorElement.textContent = message;
  errorElement.classList.add("show");
  updateConfirmButton();
}

function clearError(field) {
  const errorElement = field === "from" ? elements.fromError : elements.toError;
  errorElement.textContent = "";
  errorElement.classList.remove("show");
}

if (document.readyState === "loading") {
  document.addEventListener("DOMContentLoaded", init);
} else {
  init();
}
